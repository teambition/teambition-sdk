# 如何使用 Teambition SDK

对于 Web 开发者来说，可以通过两种方式使用 Teambition SDK。一种方式是，把它仅仅当作是 HTTP 请求和 WebSocket 推送的封装，使用最基础、最原始的 API。另外一种方式是，使用高度抽象的 API，用数据流的方式去管理应用的状态。

如果想要使用封装程度更高的 API，需要首先掌握 RxJS 的基本概念，这些 API 都是基于 RxJS 封装的，可以把 SDK 理解为一个黑盒，内部做了比较复杂的事情，整体就好像一个类似 CPU 的集成电路块，可以把它用在不同的地方。

比如说，我们想要基于 Teambition 的 API，实现一个自己的 Todolist 应用，不涉及其它数据，可以很方便通过 SDK 提供的功能实现。示意图如下：

```
View
|
Teambition SDK
|
Teambition Service
```

又或者，我们想基于 Teambition 的数据，做一些项目管理功能，在此过程中，可能会使用到其它一些非 Teambition API，也可以把 SDK 的输出流与其它数据整合起来进行界面渲染。示意图如下：

```
View
|
组合的数据层 ------------
|                      |
Teambition SDK         其它第三方 API
|                      |
Teambition Service     第三方服务
```

我们通过两个实际的例子来说明这个开发过程。

## 使用 Teambition SDK 构建自己的 TodoList

在 Teambition 的模型中，存在企业、项目、任务分组、任务阶段、任务、子任务等若干级别，其中，任务分组、任务阶段、子任务都是可选的，项目也可以不挂在企业下面，直接作为个人项目。

所以，我们如果只是为了实现一个可存储的 TodoList，可以只使用这里面的项目、任务这两个级别，甚至连项目都不必突出，作为隐含的一个要素即可。

对任务的操作体现在 Teambition SDK 的 TaskAPI 中，比如说，我们常用的有这么几个 API：

- getProjectTasks
- create
- delete
- update，包括一些特殊化的 update 接口

对于一个 TodoList 应用来说，我们可以固定一个项目 id，然后，剩下的事情可以都通过这4个 API 来完成。

查询列表的过程如下：

```TypeScript
taskAPI.getProjectTasks(projectId)
  .subscribe(tasks => {
    // 这里已经查到状态为“未完成”的任务了，可以用于界面展示
    // 此处标记为 A
    this.uncompletedTasks = tasks
  })
taskAPI.getProjectDoneTasks(projectId)
  .subscribe(tasks => {
    // 这里已经查到状态为“已完成”的任务了，可以用于界面展示
    // 此处标记为 B
    this.completedTasks = tasks
  })
```

这么两个接口，组合起来，就已经把当前项目下所有的任务查询出来了。

但我们刚才这两个接口是比较高级的接口，跟直接进行普通的请求还是不一样的，从现在这个场景下还是看不出来，我们继续。

当任务列表展示出来之后，我们就需要给任务添加一些其它功能，比如说，打开任务详情。

假设用户把列表和详情实现成了不同组件，任务列表和任务详情同时打开，并且互相数据是隔离的，使用类似 immutable 的机制，那么，在点击列表中的某一条任务的时候，详情界面中展示该任务的更详细内容。

因为任务中可能会有更复杂的字段，所以在任务详情界面会需要使用专门的API去获取单条任务（直接使用列表中的数据也可以，只是会少一些字段，如果不需要那些字段，可以这么做）：

```TypeScript
taskApi.get(taskId)
  .subscribe(task => {
    // 这里查到这条任务了，可以用于展示
    // 此处标记为 C
    this.currentTask = task
  })
```

当这两块界面完成之后，我们可以点击任务上的复选框，切换任务的完成状态。

所以我们就会这样调用API：

```TypeScript
taskAPI.updateStatus(taskId, completed)
  .subscribe(updatedTask => {
    // 更新成功，使用新的数据刷新界面
    // 此处标记为 D
    this.currentTask = updatedTask
  })
```

但是，我们面临的不仅仅是更新任务本身所对应的界面，很可能还有一些情况，考虑我们这个完成任务的操作是在两种不同场景做的：

- 点击了详情中的完成复选框
- 点击了列表中当前展示详情那条任务的复选框

无论是点哪边，都会面临数据同步的问题。这时候，就可以体会到 Teambition SDK 流式封装的优势了，因为，不管在哪里点，只要调用的是 updateStatus 这个 API：

- 标记 C 的地方，会自动得到一次更新，更新内容是：状态被修改过之后，完整的 task
- 标记 A 和 B 的地方，都会自动得到一次更新，更新内容是：
  - 如果任务是被改成完成状态
    - A 得到一个上次未完成任务数组排除了此次更新任务的剩余部分
    - B 得到一个上次已完成任务数组添加了此次更新任务的剩余部分
  - 如果任务是被改成未完成状态
    - A 得到一个上次未完成任务数组添加了此次更新任务的剩余部分
    - B 得到一个上次已完成任务数组排除了此次更新任务的剩余部分

并且，以上所述，都是 immutable 的数据，也就是说，新旧数据不存在共同引用，这么一来，如果视图层使用 VueJS 或者 React 之类的东西来渲染，只需重新更新数据引用的即可，视图层无需处理任何后续的东西，以上四处代码都不需要修改即可自动响应后续变动。

所以，从这里我们可以看到，SDK 把数据的更新在内部做了关联，对于视图层来说，只需进行查询的订阅，后续这个数据的任何变动都会被主动推过来。

以上，我们提到的都是基于基本的 HTTP 接口构建自己的 TodoList，其实，Teambition SDK 还支持 WebSocket 推送，比如说，两个用户处于同一个项目，用户 A 创建、修改、删除了任务，用户 B 都会收到通知，从而可以同步自己的界面状态。

那么，这么厉害的功能，怎么集成到我们自己的应用中来呢？其实，这个东西的集成更加简单，基本都不用写代码，也不必修改之前的业务代码，只需额外引入一个库即可。

引入了这个库之后，如果有其它用户对我们刚才请求的任务作了修改，对应的 A、B、C 几个地方，都会实时收到通知，以达到自动刷新界面的目的。

这是怎么回事呢？

因为这是另外一个黑盒子，当它跟 Teambition SDK 组合起来的时候，是这样的：

```
视图层代码
|
Teambition SDK -------- WebSocket补丁库
|                       |
RESTful Service         WebSocket Service
|                       |
Core Service -----------
```

当引入了这个补丁库的时候，服务端推送过来的所有消息都会被解析，然后合并到对应的数据上，并且对已有的订阅者进行发送。
